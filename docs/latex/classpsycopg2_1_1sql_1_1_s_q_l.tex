\hypertarget{classpsycopg2_1_1sql_1_1_s_q_l}{}\doxysection{psycopg2.\+sql.\+SQL Class Reference}
\label{classpsycopg2_1_1sql_1_1_s_q_l}\index{psycopg2.sql.SQL@{psycopg2.sql.SQL}}


Inheritance diagram for psycopg2.\+sql.\+SQL\+:
% FIG 0


Collaboration diagram for psycopg2.\+sql.\+SQL\+:
% FIG 1
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{classpsycopg2_1_1sql_1_1_s_q_l_a7790f689e8b1c56eb8c03ed0ecdab050}{\+\_\+\+\_\+init\+\_\+\+\_\+}} (self, \mbox{\hyperlink{classpsycopg2_1_1sql_1_1_s_q_l_ad08e0971702cbfe9fd4242b848a6af77}{string}})
\item 
def \mbox{\hyperlink{classpsycopg2_1_1sql_1_1_s_q_l_ad08e0971702cbfe9fd4242b848a6af77}{string}} (self)
\item 
def \mbox{\hyperlink{classpsycopg2_1_1sql_1_1_s_q_l_a8fa701e4315e347a6474279880e9ef4f}{as\+\_\+string}} (self, context)
\item 
def \mbox{\hyperlink{classpsycopg2_1_1sql_1_1_s_q_l_a7eaebc5350213c19a6ea332ec4ccfb0b}{format}} (self, $\ast$args, $\ast$$\ast$kwargs)
\item 
def \mbox{\hyperlink{classpsycopg2_1_1sql_1_1_s_q_l_a07e8d594a28b5541d7fa67f0e60fd9ed}{join}} (self, seq)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}A `Composable` representing a snippet of SQL statement.

`!SQL` exposes `join()` and `format()` methods useful to create a template
where to merge variable parts of a query (for instance field or table
names).

The *string* doesn't undergo any form of escaping, so it is not suitable to
represent variable identifiers or values: you should only use it to pass
constant strings representing templates or snippets of SQL statements; use
other objects such as `Identifier` or `Literal` to represent variable
parts.

Example::

    >>> query = sql.SQL("select {0} from {1}").format(
    ...    sql.SQL(', ').join([sql.Identifier('foo'), sql.Identifier('bar')]),
    ...    sql.Identifier('table'))
    >>> print(query.as_string(conn))
    select "foo", "bar" from "table"
\end{DoxyVerb}
 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classpsycopg2_1_1sql_1_1_s_q_l_a7790f689e8b1c56eb8c03ed0ecdab050}\label{classpsycopg2_1_1sql_1_1_s_q_l_a7790f689e8b1c56eb8c03ed0ecdab050}} 
\index{psycopg2.sql.SQL@{psycopg2.sql.SQL}!\_\_init\_\_@{\_\_init\_\_}}
\index{\_\_init\_\_@{\_\_init\_\_}!psycopg2.sql.SQL@{psycopg2.sql.SQL}}
\doxysubsubsection{\texorpdfstring{\_\_init\_\_()}{\_\_init\_\_()}}
{\footnotesize\ttfamily def psycopg2.\+sql.\+SQL.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{string }\end{DoxyParamCaption})}



Reimplemented from \mbox{\hyperlink{classpsycopg2_1_1sql_1_1_composable}{psycopg2.\+sql.\+Composable}}.



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classpsycopg2_1_1sql_1_1_s_q_l_a8fa701e4315e347a6474279880e9ef4f}\label{classpsycopg2_1_1sql_1_1_s_q_l_a8fa701e4315e347a6474279880e9ef4f}} 
\index{psycopg2.sql.SQL@{psycopg2.sql.SQL}!as\_string@{as\_string}}
\index{as\_string@{as\_string}!psycopg2.sql.SQL@{psycopg2.sql.SQL}}
\doxysubsubsection{\texorpdfstring{as\_string()}{as\_string()}}
{\footnotesize\ttfamily def psycopg2.\+sql.\+SQL.\+as\+\_\+string (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{context }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the string value of the object.

:param context: the context to evaluate the string into.
:type context: `connection` or `cursor`

The method is automatically invoked by `~cursor.execute()`,
`~cursor.executemany()`, `~cursor.copy_expert()` if a `!Composable` is
passed instead of the query string.
\end{DoxyVerb}
 

Reimplemented from \mbox{\hyperlink{classpsycopg2_1_1sql_1_1_composable_a77b13bb7380175e59facce7566dfb5f6}{psycopg2.\+sql.\+Composable}}.

\mbox{\Hypertarget{classpsycopg2_1_1sql_1_1_s_q_l_a7eaebc5350213c19a6ea332ec4ccfb0b}\label{classpsycopg2_1_1sql_1_1_s_q_l_a7eaebc5350213c19a6ea332ec4ccfb0b}} 
\index{psycopg2.sql.SQL@{psycopg2.sql.SQL}!format@{format}}
\index{format@{format}!psycopg2.sql.SQL@{psycopg2.sql.SQL}}
\doxysubsubsection{\texorpdfstring{format()}{format()}}
{\footnotesize\ttfamily def psycopg2.\+sql.\+SQL.\+format (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{$\ast$}]{args,  }\item[{$\ast$$\ast$}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Merge `Composable` objects into a template.

:param `Composable` args: parameters to replace to numbered
    (``{0}``, ``{1}``) or auto-numbered (``{}``) placeholders
:param `Composable` kwargs: parameters to replace to named (``{name}``)
    placeholders
:return: the union of the `!SQL` string with placeholders replaced
:rtype: `Composed`

The method is similar to the Python `str.format()` method: the string
template supports auto-numbered (``{}``), numbered (``{0}``,
``{1}``...), and named placeholders (``{name}``), with positional
arguments replacing the numbered placeholders and keywords replacing
the named ones. However placeholder modifiers (``{0!r}``, ``{0:<10}``)
are not supported. Only `!Composable` objects can be passed to the
template.

Example::

    >>> print(sql.SQL("select * from {} where {} = %s")
    ...     .format(sql.Identifier('people'), sql.Identifier('id'))
    ...     .as_string(conn))
    select * from "people" where "id" = %s

    >>> print(sql.SQL("select * from {tbl} where {pkey} = %s")
    ...     .format(tbl=sql.Identifier('people'), pkey=sql.Identifier('id'))
    ...     .as_string(conn))
    select * from "people" where "id" = %s\end{DoxyVerb}
 \mbox{\Hypertarget{classpsycopg2_1_1sql_1_1_s_q_l_a07e8d594a28b5541d7fa67f0e60fd9ed}\label{classpsycopg2_1_1sql_1_1_s_q_l_a07e8d594a28b5541d7fa67f0e60fd9ed}} 
\index{psycopg2.sql.SQL@{psycopg2.sql.SQL}!join@{join}}
\index{join@{join}!psycopg2.sql.SQL@{psycopg2.sql.SQL}}
\doxysubsubsection{\texorpdfstring{join()}{join()}}
{\footnotesize\ttfamily def psycopg2.\+sql.\+SQL.\+join (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{seq }\end{DoxyParamCaption})}

\begin{DoxyVerb}Join a sequence of `Composable`.

:param seq: the elements to join.
:type seq: iterable of `!Composable`

Use the `!SQL` object's *string* to separate the elements in *seq*.
Note that `Composed` objects are iterable too, so they can be used as
argument for this method.

Example::

    >>> snip = sql.SQL(', ').join(
    ...     sql.Identifier(n) for n in ['foo', 'bar', 'baz'])
    >>> print(snip.as_string(conn))
    "foo", "bar", "baz"
\end{DoxyVerb}
 \mbox{\Hypertarget{classpsycopg2_1_1sql_1_1_s_q_l_ad08e0971702cbfe9fd4242b848a6af77}\label{classpsycopg2_1_1sql_1_1_s_q_l_ad08e0971702cbfe9fd4242b848a6af77}} 
\index{psycopg2.sql.SQL@{psycopg2.sql.SQL}!string@{string}}
\index{string@{string}!psycopg2.sql.SQL@{psycopg2.sql.SQL}}
\doxysubsubsection{\texorpdfstring{string()}{string()}}
{\footnotesize\ttfamily def psycopg2.\+sql.\+SQL.\+string (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}The string wrapped by the `!SQL` object.\end{DoxyVerb}
 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
venv/\+Lib/site-\/packages/psycopg2/sql.\+py\end{DoxyCompactItemize}
