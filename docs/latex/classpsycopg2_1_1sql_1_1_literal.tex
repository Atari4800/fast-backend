\hypertarget{classpsycopg2_1_1sql_1_1_literal}{}\doxysection{psycopg2.\+sql.\+Literal Class Reference}
\label{classpsycopg2_1_1sql_1_1_literal}\index{psycopg2.sql.Literal@{psycopg2.sql.Literal}}


Inheritance diagram for psycopg2.\+sql.\+Literal\+:
% FIG 0


Collaboration diagram for psycopg2.\+sql.\+Literal\+:
% FIG 1
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{classpsycopg2_1_1sql_1_1_literal_a7644bcf208e3a27c25103d09b7fae554}{wrapped}} (self)
\item 
def \mbox{\hyperlink{classpsycopg2_1_1sql_1_1_literal_a23caf47f221ff47816c305d5cf49054a}{as\+\_\+string}} (self, context)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}A `Composable` representing an SQL value to include in a query.

Usually you will want to include placeholders in the query and pass values
as `~cursor.execute()` arguments. If however you really really need to
include a literal value in the query you can use this object.

The string returned by `!as_string()` follows the normal :ref:`adaptation
rules <python-types-adaptation>` for Python objects.

Example::

    >>> s1 = sql.Literal("foo")
    >>> s2 = sql.Literal("ba'r")
    >>> s3 = sql.Literal(42)
    >>> print(sql.SQL(', ').join([s1, s2, s3]).as_string(conn))
    'foo', 'ba''r', 42\end{DoxyVerb}
 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classpsycopg2_1_1sql_1_1_literal_a23caf47f221ff47816c305d5cf49054a}\label{classpsycopg2_1_1sql_1_1_literal_a23caf47f221ff47816c305d5cf49054a}} 
\index{psycopg2.sql.Literal@{psycopg2.sql.Literal}!as\_string@{as\_string}}
\index{as\_string@{as\_string}!psycopg2.sql.Literal@{psycopg2.sql.Literal}}
\doxysubsubsection{\texorpdfstring{as\_string()}{as\_string()}}
{\footnotesize\ttfamily def psycopg2.\+sql.\+Literal.\+as\+\_\+string (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{context }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the string value of the object.

:param context: the context to evaluate the string into.
:type context: `connection` or `cursor`

The method is automatically invoked by `~cursor.execute()`,
`~cursor.executemany()`, `~cursor.copy_expert()` if a `!Composable` is
passed instead of the query string.
\end{DoxyVerb}
 

Reimplemented from \mbox{\hyperlink{classpsycopg2_1_1sql_1_1_composable_a77b13bb7380175e59facce7566dfb5f6}{psycopg2.\+sql.\+Composable}}.

\mbox{\Hypertarget{classpsycopg2_1_1sql_1_1_literal_a7644bcf208e3a27c25103d09b7fae554}\label{classpsycopg2_1_1sql_1_1_literal_a7644bcf208e3a27c25103d09b7fae554}} 
\index{psycopg2.sql.Literal@{psycopg2.sql.Literal}!wrapped@{wrapped}}
\index{wrapped@{wrapped}!psycopg2.sql.Literal@{psycopg2.sql.Literal}}
\doxysubsubsection{\texorpdfstring{wrapped()}{wrapped()}}
{\footnotesize\ttfamily def psycopg2.\+sql.\+Literal.\+wrapped (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}The object wrapped by the `!Literal`.\end{DoxyVerb}
 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
venv/\+Lib/site-\/packages/psycopg2/sql.\+py\end{DoxyCompactItemize}
